<aside class="appointment-finder collapsible {% if static|default %}static{% else %}collapsed{% endif %}" aria-label="Anmeldung appointment finder">
    {% if not static|default %}
        <div class="header">
            <h2>
              <span class="no-desktop">Appointment finder</span>
              <span class="no-mobile">Anmeldung appointment finder</span>
            </h2>
        </div>
    {% endif %}
    {% raw %}
        <div class="body">
            <p v-if="isConnected === null">
                Connecting to the appointment finder...
            </p>
            <div class="error" v-if="isConnected === false">
                <h3>Can't connect to the appointment finder</h3>
                <p>Try refreshing the page. You can also <a target="_blank" href="/out/appointment-anmeldung">check Berlin.de</a>, <a href="tel:+49115">call 115</a> or <a href="/guides/berlin-burgeramt-appointment#email-the-burgeramt">email your <em>Bürgeramt</em></a>. If this keeps happening, <a href="/contact">email me</a>.</p>
            </div>
            <div class="error" v-if="isConnected && hasError">
                <h3>Can't connect to Berlin.de</h3>
                <p>Berlin.de is having issues. If this keeps happening, <a href="/contact">email me</a>.</p>
            </div>
            <div class="error" v-if="isConnected && appointments.length === 0">
                <h3>No appointments found</h3>
                <p>This happens often. <a target="_blank" href="/out/appointment-anmeldung">Check Berlin.de</a>, <a href="tel:+49115">call 115</a> or <a href="/guides/berlin-burgeramt-appointment#email-the-burgeramt">email your <em>Bürgeramt</em></a>. It's sometimes faster.</p>
                <p v-if="!isDuringOfficeHours">There are more appointments on weekdays between 8:00 and 17:00.</p>
            </div>
            <div class="options" v-if="appointments.length > 0">
                <a v-for="appointment in appointments" href="/out/appointment-anmeldung" target="_blank" title="Book this appointment" :key="appointment.date">
                    <svg fill="currentColor" width="700pt" height="700pt" version="1.1" viewBox="0 0 700 700" xmlns="http://www.w3.org/2000/svg">
                        <path d="m525 97.477h-43.75v-21.176c0-9.3789-5.0039-18.043-13.125-22.734-8.1211-4.6875-18.129-4.6875-26.25 0-8.1211 4.6914-13.125 13.355-13.125 22.734v21.176h-157.5v-21.176c0-9.3789-5.0039-18.043-13.125-22.734-8.1211-4.6875-18.129-4.6875-26.25 0-8.1211 4.6914-13.125 13.355-13.125 22.734v21.176h-43.75c-16.246 0-31.824 6.4531-43.309 17.938-11.488 11.488-17.941 27.066-17.941 43.312v289.97c0 16.246 6.4531 31.824 17.941 43.312 11.484 11.484 27.062 17.938 43.309 17.938h350c16.246 0 31.824-6.4531 43.309-17.938 11.488-11.488 17.941-27.066 17.941-43.312v-289.97c0-16.246-6.4531-31.824-17.941-43.312-11.484-11.484-27.062-17.938-43.309-17.938zm-350 52.5h43.75v3.8516-0.003906c0 9.3789 5.0039 18.043 13.125 22.734 8.1211 4.6875 18.129 4.6875 26.25 0 8.1211-4.6914 13.125-13.355 13.125-22.734v-3.8477h157.5v3.8516-0.003906c0 9.3789 5.0039 18.043 13.125 22.734 8.1211 4.6875 18.129 4.6875 26.25 0 8.1211-4.6914 13.125-13.355 13.125-22.734v-3.8477h43.75c2.3203 0 4.5469 0.92188 6.1875 2.5625 1.6406 1.6406 2.5625 3.8672 2.5625 6.1875v54.773h-367.5v-54.773c0-4.8359 3.918-8.75 8.75-8.75zm350 307.47h-350c-4.832 0-8.75-3.918-8.75-8.75v-182.7h367.5v182.7c0 2.3203-0.92188 4.5469-2.5625 6.1875s-3.8672 2.5625-6.1875 2.5625z"/>
                    </svg>
                    <strong>{{ prettyDate(appointment.date) }}</strong>
                    <small>{{ relativeDate(appointment.date) }}</small>
                </a>
            </div>
            <p class="timer" v-if="isConnected && !hasError && secondsToNextMessage > 0">
                Checking again in {{ secondsToNextMessage }} {{ secondsToNextMessage > 1 ? 'seconds' : 'second' }}.
            </p>
            <p class="timer" v-if="isConnected && !hasError && secondsToNextMessage <= 0">
                Looking for appointments...
            </p>
            <label v-if="isConnected" class="checkbox">
                <input type="checkbox" v-model="playSoundOnNewAppointments"> Play a sound when there are {{ appointments.length > 0 ? '' : 'new' }} appointments
            </label>
        </div>
    {% endraw %}
</aside>
{% include '/js/vue.js' %}
{% include '/js/utils.js' %}
{% js %}
  const ding = new Audio('/js/ding.wav');
  document.querySelectorAll(".appointment-finder").forEach((appointmentFinderWidget) => {
    var app = new Vue({
      el: appointmentFinderWidget,
      data() {
        return {
          isConnected: null,
          hasError: false,
          originalPageTitle: document.title,
          playSoundOnNewAppointments: getDefaultBoolean('playSoundOnNewAppointments', false),
          reconnectInterval: null,
          socket: null,
          lastMessage: null,
          secondsToNextMessage: null,
        }
      },
      mounted() {
        this.connect();

        // Connect to API, check every 3 minutes
        setInterval(() => {
          if(this.lastChecked) {
            const nextCheck = new Date(this.lastChecked.getTime() + 180*1000);
            this.secondsToNextMessage = Math.round(
              Math.max((nextCheck.getTime() - (new Date()).getTime()) / 1000, 0)
            );
          }
          else {
            this.secondsToNextMessage = null;
          }
        }, 500);
      },
      methods: {
        connect() {
          this.socket = new WebSocket(`wss://${window.location.hostname}/api/appointments`);
          this.socket.addEventListener('message', this.onMessage);
          this.socket.addEventListener('error', this.onError);
          this.socket.addEventListener('open', this.onConnect);
          this.socket.addEventListener('close', this.onDisonnect);
        },
        onConnect(event) {
          console.log('Connected to appointments API');
          this.isConnected = true;
          if(this.reconnectInterval){ clearInterval(this.reconnectInterval) }
          this.reconnectInterval = null;
        },
        onDisonnect(event) {
          this.isConnected = false;
          this.lastMessage = null;
          console.warn('Lost connection to appointments API. Reconnecting...');
          if(!this.reconnectInterval) {
            this.reconnectInterval = setInterval(this.connect, 5000)
          }
        },
        onMessage(event) {
          if(!event.data) return;
          const currentMessage = JSON.parse(event.data);
          if(currentMessage) {
            if(currentMessage.status === 200){
              this.hasError = false;
            }
            else{
              console.error("Could not fetch appointments", event.data);
              this.hasError = true;
              return;
            }
          }
          this.lastMessage = currentMessage;
        },
        onError(event) {
          console.error('WebSocket error', event);
          this.hasError = true;
          this.lastMessage = null;
        },
        prettyDate(date) {
          const month = [
            'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December',
          ][date.getMonth()];
          return `${month} ${date.getDate()}`;
        },
        dayOfWeek(date) {
          return ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][date.getDay()];
        },
        weekDiff(date1, date2) {
          const firstDayOfWeekDate1 = new Date(date1);
          firstDayOfWeekDate1.setDate(date1.getDate() - (date1.getDay() + 6) % 7);
          firstDayOfWeekDate1.setHours(0,0,0,0);

          const firstDayOfWeekDate2 = new Date(date2);
          firstDayOfWeekDate2.setDate(date2.getDate() - (date2.getDay() + 6) % 7);
          firstDayOfWeekDate2.setHours(0,0,0,0);

          const firstDayOfWeekDiff = Math.floor((firstDayOfWeekDate1 - firstDayOfWeekDate2) / (24 * 60 * 60 * 1000));
          return Math.ceil(firstDayOfWeekDiff / 7);
        },
        relativeDate(date) {
          const now = new Date();
          const daysDiff = Math.abs(Math.ceil((date - now) / (24 * 60 * 60 * 1000)));
          const weekDiff = this.weekDiff(date, now);
          if(daysDiff === 0) {
            return 'Today';
          }
          else if(daysDiff === 1) {
            return 'Tomorrow';
          }
          else if(weekDiff === 0) {
            return `This ${this.dayOfWeek(date)}`;
          }
          else if(weekDiff === 1) {
            return `Next ${this.dayOfWeek(date)}`;
          }
          else {
            return `${this.dayOfWeek(date)} in ${weekDiff} weeks`;
          }
        },
        updateWindowTitle() {
          // Only control the title on the dedicated tool page
          if(!window.location.pathname.startsWith('/tools/appointment-finder')) {
            return;
          }

          if(!this.appointments.length) {
            document.title = this.originalPageTitle;
            return;
          }

          const timeToEarliestAppointment = this.appointments[0].date.getTime() - (new Date()).getTime();
          const daysToEarliestAppointment = Math.ceil(timeToEarliestAppointment / (1000*60*60*24));

          if(daysToEarliestAppointment === 0) {
            document.title = `(${this.appointments.length}) Appointments today!`;
          }
          else if(daysToEarliestAppointment === 1) {
            document.title = `(${this.appointments.length}) Appointment tomorrow!`;
          }
          else {
            document.title = `(${this.appointments.length}) Appointments in ${daysToEarliestAppointment} days`;
          }
        }
      },
      computed: {
        appointments() {
          if(!this.lastMessage) { return []; }

          return this.lastMessage.appointmentDates.sort().map(dateString => { return {
            date: new Date(dateString),
          }});
        },
        lastChecked() {
          return this.lastMessage ? new Date(this.lastMessage.time) : null;
        },
        isRateLimited() {
          return this.lastMessage ? this.lastMessage.status === 502 : false;
        },
        isDuringOfficeHours() {
          const now = new Date();
          return now.getHours() >= 8  && now.getHours() < 17 && now.getDay() > 0 && now.getDay() < 6;
        },
      },
      watch: {
        appointments(newAppointments, oldAppointments) {
          if(newAppointments.length && this.playSoundOnNewAppointments) {
            ding.play();
          }
          this.updateWindowTitle();
        },
        playSoundOnNewAppointments(isChecked) {
          if(isChecked){
            ding.play();
          }
          setDefaultBoolean('playSoundOnNewAppointments', isChecked);
        }
      }
    });
  });
{% endjs %}